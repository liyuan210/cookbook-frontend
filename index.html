<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1203497357786022"
     crossorigin="anonymous"></script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W22XF5EE60"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W22XF5EE60');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Culinary Assistant - What Would You Like to Eat?</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Warm Neutrals & Sage -->
    <!-- Application Structure Plan: The application is designed with a simple, linear three-stage user flow: 1) Input Stage, 2) Loading Stage, and 3) Results Stage. This structure directly mirrors the user's task of entering ingredients, waiting for a recipe, and then viewing it. This task-oriented design minimizes cognitive load and makes the application highly intuitive and easy to use. Navigation is handled by dynamically showing and hiding these three stage containers using JavaScript. -->
    <!-- Visualization & Content Choices: 
        - Report Info: User Ingredients & Preferences -> Goal: Collect user input -> Method: Interactive tag-based input field. Justification: More user-friendly and clear than a simple textarea. 
        - Report Info: Recipe Generation -> Goal: Provide feedback during processing -> Method: CSS loading spinner and text. Justification: Manages user expectations during the simulated API call. 
        - Report Info: Generated Recipe (name, description, ingredients, instructions) -> Goal: Clearly display the recipe -> Method: A structured card layout using Tailwind CSS. 
        - Report Info: `ingredients_breakdown` with `available` and `missing` status -> Goal: Highlight the key value proposition -> Method: A list where each item is styled with different colors and icons (green check for available, orange warning for missing). This immediately draws the user's attention to what they have and what they need.
        - Library/Method: Vanilla JavaScript for all logic. No external JS libraries for logic are needed.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap');
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #FDFBF8;
            color: #4A4A4A;
        }
        
        .chat-bubble {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            margin-bottom: 12px;
            word-wrap: break-word;
        }
        
        .user-bubble {
            background-color: #3B82F6;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 6px;
        }
        
        .ai-bubble {
            background-color: #F3F4F6;
            color: #374151;
            margin-right: auto;
            border-bottom-left-radius: 6px;
        }
        
        .typing-indicator {
            display: flex;
            padding: 16px;
            background-color: #F3F4F6;
            border-radius: 18px;
            margin-right: auto;
            max-width: 80px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #9CA3AF;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        .example-tag {
            display: inline-block;
            padding: 6px 12px;
            margin: 4px;
            background-color: #E5E7EB;
            color: #6B7280;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .example-tag:hover {
            background-color: #3B82F6;
            color: white;
        }
        
        .recipe-card {
            background: white;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin: 16px 0;
        }
        
        .fade-in {
            animation: fadeIn 0.6s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="antialiased">
    <div id="app" class="container mx-auto p-4 md:p-8 max-w-4xl">
        
                <!-- ===== ‰∏ªÊ†áÈ¢ò ===== -->
            <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-800">üçΩÔ∏è AI Culinary Assistant</h1>
            <p class="mt-4 text-lg text-gray-600">Tell me what you're craving, and AI will recommend the perfect recipe for you!</p>
            </header>

        <!-- ===== ÊêúÁ¥¢ËæìÂÖ•Âå∫Âüü ===== -->
        <div id="searchSection" class="mb-8">
            <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-100">
                <div class="relative">
                    <input 
                        type="text" 
                        id="foodSearchInput" 
                        placeholder="What would you like to eat? e.g., Spicy food, Quick meals, Vegetarian..."
                        class="w-full p-4 pr-12 text-lg border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                    >
                    <button id="searchBtn" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-blue-500 text-xl">
                        üîç
                    </button>
                </div>
                
                <!-- Á§∫‰æãÊèêÁ§∫ -->
                <div class="mt-4">
                    <p class="text-sm text-gray-500 mb-2">üí° Try these:</p>
                    <div class="flex flex-wrap">
                        <span class="example-tag" onclick="quickSearch('Chinese cuisine')">Chinese</span>
                        <span class="example-tag" onclick="quickSearch('Something spicy')">Spicy</span>
                        <span class="example-tag" onclick="quickSearch('Quick and easy')">Quick & Easy</span>
                        <span class="example-tag" onclick="quickSearch('Light and healthy')">Light & Healthy</span>
                        <span class="example-tag" onclick="quickSearch('Vegetarian food')">Vegetarian</span>
                        <span class="example-tag" onclick="quickSearch('Comfort food')">Comfort Food</span>
                        <button class="example-tag bg-red-100 hover:bg-red-200" onclick="testAPIConnection()">üîß Test API</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ===== ÂØπËØùÂå∫Âüü ===== -->
        <div id="chatSection" class="mb-8">
            <div id="chatContainer" class="bg-white rounded-2xl shadow-lg border border-gray-100 p-6 min-h-[200px] max-h-[600px] overflow-y-auto">
                <!-- ÂØπËØùÂÜÖÂÆπÂ∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
                                <div id="chatWelcome" class="text-center text-gray-500 py-8">
                    <div class="text-4xl mb-4">üë®‚Äçüç≥</div>
                    <p>Welcome! Tell me what you're craving, and I'll recommend delicious recipes for you</p>
        </div>
            </div>
            
            <!-- ËøΩÈóÆËæìÂÖ•Ê°Ü -->
            <div id="followUpSection" class="hidden mt-4">
                <div class="flex gap-2">
                    <input 
                        type="text" 
                        id="followUpInput" 
                        placeholder="Ask follow-up questions... e.g., Is there an easier way to make this?"
                        class="flex-1 p-3 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none"
                    >
                    <button id="followUpBtn" class="px-6 py-3 bg-blue-500 text-white rounded-xl hover:bg-blue-600 transition-colors">
                        Ask
                    </button>
                </div>
            </div>
        </div>

        <!-- ===== ËèúË∞±ËØ¶ÊÉÖÂ±ïÁ§∫Âå∫Âüü ===== -->
        <div id="recipeDetailSection" class="hidden">
            <div class="recipe-card fade-in">
                <div class="text-center mb-6">
                    <h2 id="recipeName" class="text-3xl font-bold text-gray-800 mb-2"></h2>
                    <p id="recipeDescription" class="text-gray-600"></p>
                </div>
                
                <!-- ËèúË∞±Âü∫Êú¨‰ø°ÊÅØ -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 text-center">
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <p class="text-sm text-gray-500">Cook Time</p>
                        <p id="recipeTime" class="text-xl font-bold text-blue-600"></p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <p class="text-sm text-gray-500">Difficulty</p>
                        <p id="recipeDifficulty" class="text-xl font-bold text-blue-600"></p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <p class="text-sm text-gray-500">Cuisine</p>
                        <p id="recipeCuisine" class="text-xl font-bold text-blue-600"></p>
                    </div>
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <button id="favoriteBtn" class="w-full text-xl text-gray-400 hover:text-red-500 transition-colors">
                            ‚ù§Ô∏è Favorite
                        </button>
                    </div>
                </div>

                <!-- È£üÊùêÊ∏ÖÂçï -->
                <div class="mb-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">ü•ò Ingredients</h3>
                    <ul id="ingredientsList" class="space-y-2">
                        <!-- Âä®ÊÄÅÁîüÊàê -->
                    </ul>
                </div>

                <!-- ÁÉπÈ•™Ê≠•È™§ -->
                <div class="mb-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">üë©‚Äçüç≥ Instructions</h3>
                    <ol id="instructionsList" class="space-y-3">
                        <!-- Âä®ÊÄÅÁîüÊàê -->
                    </ol>
                </div>
                
                <!-- Â∞èË¥¥Â£´ -->
                <div id="tipsContainer" class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r-lg">
                    <h4 class="font-bold text-yellow-800 mb-2">üí° Cooking Tips</h4>
                    <p id="cookingTips" class="text-yellow-700"></p>
                </div>
            </div>
        </div>

        <!-- ===== Â∫ïÈÉ®ÊåâÈíÆ ===== -->
        <div id="actionButtons" class="hidden text-center mt-8">
            <button id="newSearchBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-8 py-3 rounded-xl mr-4 transition-colors">
                New Search
            </button>
            <button id="anotherRecipeBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-8 py-3 rounded-xl transition-colors">
                Try Another Recipe
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // API ÈÖçÁΩÆ - Ê≠£Á°ÆÁöÑOpenRouterÈÖçÁΩÆ
            const API_CONFIG = {
                apiKey: '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',
                baseUrl: 'https://openrouter.ai/api/v1',
                model: 'deepseek/deepseek-r1-0528-qwen3-8b:free'  // Ê≠£Á°ÆÁöÑÂÖçË¥πÊ®°ÂûãÂêçÁß∞
            };

            // Ê∑ªÂä†APIÊµãËØïÂáΩÊï∞
            async function testAPI() {
                console.log('ÊµãËØïAPIËøûÊé•...');
                try {
                    const response = await fetch(`${API_CONFIG.baseUrl}/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${API_CONFIG.apiKey}`
                        },
                        body: JSON.stringify({
                            model: API_CONFIG.model,
                            messages: [{ role: 'user', content: '‰Ω†Â•Ω' }],
                            max_tokens: 100
                        })
                    });
                    
                    console.log('APIÂìçÂ∫îÁä∂ÊÄÅ:', response.status);
                    const data = await response.json();
                    console.log('APIÂìçÂ∫îÊï∞ÊçÆ:', data);
                    
                    if (!response.ok) {
                        throw new Error(`APIÈîôËØØ: ${response.status} - ${JSON.stringify(data)}`);
                    }
                    
                    return data;
                } catch (error) {
                    console.error('APIÊµãËØïÂ§±Ë¥•:', error);
                    throw error;
                }
            }

            // ÂØπËØùÂéÜÂè≤
            let conversationHistory = [];
            let currentContext = '';

            // DOM ÂÖÉÁ¥†
            const foodSearchInput = document.getElementById('foodSearchInput');
            const searchBtn = document.getElementById('searchBtn');
            const chatContainer = document.getElementById('chatContainer');
            const chatWelcome = document.getElementById('chatWelcome');
            const followUpSection = document.getElementById('followUpSection');
            const followUpInput = document.getElementById('followUpInput');
            const followUpBtn = document.getElementById('followUpBtn');
            const recipeDetailSection = document.getElementById('recipeDetailSection');
            const actionButtons = document.getElementById('actionButtons');

            // ÂàùÂßãÂåñ‰∫ã‰ª∂ÁõëÂê¨
            searchBtn.addEventListener('click', handleSearch);
            followUpBtn.addEventListener('click', handleFollowUp);
            
            foodSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSearch();
            });
            
            followUpInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleFollowUp();
            });

            // Âø´ÈÄüÊêúÁ¥¢
            window.quickSearch = function(query) {
                foodSearchInput.value = query;
                handleSearch();
            };

            // APIËøûÊé•ÊµãËØï
            window.testAPIConnection = async function() {
                chatWelcome.style.display = 'none';
                                    addChatMessage('Testing API connection...', 'user');
                    showTypingIndicator();
                    
                    try {
                        const result = await testAPI();
                        removeTypingIndicator();
                        addChatMessage('‚úÖ API connection successful! Test passed', 'ai');
                        console.log('APIÊµãËØïÊàêÂäü:', result);
                    } catch (error) {
                        removeTypingIndicator();
                        addChatMessage(`‚ùå API test failed: ${error.message}`, 'ai');
                        console.error('APIÊµãËØïËØ¶ÁªÜÈîôËØØ:', error);
                    }
            };

            // Â§ÑÁêÜÊêúÁ¥¢
            async function handleSearch() {
                const query = foodSearchInput.value.trim();
                if (!query) return;

                // ÈöêËóèÊ¨¢Ëøé‰ø°ÊÅØ
                chatWelcome.style.display = 'none';
                
                // Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØ
                addChatMessage(query, 'user');
                
                // ÊòæÁ§∫AIÊÄùËÄÉ‰∏≠
                showTypingIndicator();
                
                // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
                foodSearchInput.value = '';
                
                try {
                    // Ë∞ÉÁî®AI
                    const response = await callAI(query, 'search');
                    
                    // ÁßªÈô§ÊÄùËÄÉÊåáÁ§∫Âô®
                    removeTypingIndicator();
                    
                    // Ê∑ªÂä†AIÂõûÂ§ç
                    addChatMessage(response.message, 'ai');
                    
                    // Â¶ÇÊûúÊúâÂÖ∑‰ΩìËèúË∞±ÔºåÊòæÁ§∫ËØ¶ÊÉÖ
                    if (response.recipe) {
                        showRecipeDetail(response.recipe);
                    }
                    
                    // ÊòæÁ§∫ËøΩÈóÆÂå∫Âüü
                    followUpSection.classList.remove('hidden');
                    
                } catch (error) {
                    removeTypingIndicator();
                    console.error('ÊêúÁ¥¢APIË∞ÉÁî®Â§±Ë¥•:', error);
                    
                    // ÊòæÁ§∫ËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØ
                    let errorMessage = 'Sorry, the request failed:';
                    if (error.message.includes('401')) {
                        errorMessage = '‚ùå Invalid API key, please check your API Key';
                    } else if (error.message.includes('403')) {
                        errorMessage = '‚ùå API access denied, please check permissions';
                    } else if (error.message.includes('404')) {
                        errorMessage = '‚ùå API endpoint not found, please check URL';
                    } else if (error.message.includes('429')) {
                        errorMessage = '‚ùå API rate limit exceeded, please try again later';
                    } else if (error.message.includes('500')) {
                        errorMessage = '‚ùå Server internal error, please try again later';
                    } else {
                        errorMessage = `‚ùå Network error: ${error.message}`;
                    }
                    
                    addChatMessage(errorMessage, 'ai');
                }
            }

            // Â§ÑÁêÜËøΩÈóÆ
            async function handleFollowUp() {
                const question = followUpInput.value.trim();
                if (!question) return;

                // Ê∑ªÂä†Áî®Êà∑ËøΩÈóÆ
                addChatMessage(question, 'user');
                
                // ÊòæÁ§∫ÊÄùËÄÉ‰∏≠
                showTypingIndicator();
                
                // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
                followUpInput.value = '';

                try {
                    // Ë∞ÉÁî®AIÔºàÂ∏¶‰∏äÂØπËØùÂéÜÂè≤Ôºâ
                    const response = await callAI(question, 'followup');
                    
                    removeTypingIndicator();
                    addChatMessage(response.message, 'ai');
                    
                    // Â¶ÇÊûúÊòØÊñ∞ËèúË∞±ÔºåÊõ¥Êñ∞ÊòæÁ§∫
                    if (response.recipe) {
                        showRecipeDetail(response.recipe);
                    }
                    
                } catch (error) {
                    removeTypingIndicator();
                    console.error('ËøΩÈóÆAPIË∞ÉÁî®Â§±Ë¥•:', error);
                    
                    // ÊòæÁ§∫ËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØ
                    let errorMessage = 'Sorry, the request failed:';
                    if (error.message.includes('401')) {
                        errorMessage = '‚ùå Invalid API key, please check your API Key';
                    } else if (error.message.includes('403')) {
                        errorMessage = '‚ùå API access denied, please check permissions';
                    } else if (error.message.includes('404')) {
                        errorMessage = '‚ùå API endpoint not found, please check URL';
                    } else if (error.message.includes('429')) {
                        errorMessage = '‚ùå API rate limit exceeded, please try again later';
                    } else if (error.message.includes('500')) {
                        errorMessage = '‚ùå Server internal error, please try again later';
                    } else {
                        errorMessage = `‚ùå Network error: ${error.message}`;
                    }
                    
                    addChatMessage(errorMessage, 'ai');
                }
            }

            // Ë∞ÉÁî®AIÊé•Âè£
            async function callAI(userInput, type) {
                let prompt = '';
                
                if (type === 'search') {
                    prompt = `User said: "${userInput}"

As a professional culinary consultant, please recommend a dish. Reply strictly in the following JSON format in English:

{
    "type": "recipe",
    "message": "I recommend a delicious XXX for you!",
    "recipe": {
        "name": "Dish Name",
        "description": "Brief description of this dish's characteristics",
        "time": "15 minutes",
        "difficulty": "Easy",
        "cuisine": "Home Cooking",
        "ingredients": [
            {"name": "Ingredient Name", "amount": "Amount"}
        ],
        "instructions": ["Step 1", "Step 2", "Step 3"],
        "tips": "Cooking tips"
    }
}

Return only JSON, no other content.`;
                } else {
                    // ËøΩÈóÆÊ®°ÂºèÔºåÂ∏¶‰∏äÂØπËØùÂéÜÂè≤
                    const history = conversationHistory.slice(-4).map(h => `${h.role}: ${h.content}`).join('\n');
                    prompt = `Conversation history:
${history}

User follow-up: "${userInput}"

Please continue answering based on the previous conversation. If recommending a new recipe, use the same JSON format. Keep answers concise.`;
                }

                const response = await fetch(`${API_CONFIG.baseUrl}/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_CONFIG.apiKey}`
                    },
                    body: JSON.stringify({
                        model: API_CONFIG.model,
                        messages: [
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        max_tokens: 1500,
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`APIË∞ÉÁî®Â§±Ë¥•: ${response.status}`);
                }

                const data = await response.json();
                let content = data.choices[0].message.content.trim();
                
                // Ê∏ÖÁêÜÂèØËÉΩÁöÑmarkdownÂåÖË£ÖÂíåÂ§ö‰ΩôÂÜÖÂÆπ
                content = content.replace(/```json\s*|\s*```/g, '').trim();
                
                try {
                    // Â∞ùËØïËß£ÊûêJSON
                    const parsed = JSON.parse(content);
                    
                    // ‰øùÂ≠òÂØπËØùÂéÜÂè≤
                    conversationHistory.push({role: 'user', content: userInput});
                    conversationHistory.push({role: 'ai', content: parsed.message || 'Recommended a dish'});
                    
                    return parsed;
                } catch (e) {
                    // Â¶ÇÊûú‰∏çÊòØÊ†áÂáÜJSONÔºåÂ∞ùËØï‰ªéÊñáÊú¨‰∏≠ÊèêÂèñËèúË∞±‰ø°ÊÅØ
                    console.log('JSONËß£ÊûêÂ§±Ë¥•ÔºåÂ∞ùËØïÊô∫ËÉΩËß£Êûê:', content);
                    
                    // Êô∫ËÉΩËß£ÊûêÔºö‰ªéÊñáÊú¨‰∏≠ÊèêÂèñÁªìÊûÑÂåñ‰ø°ÊÅØ
                    const smartParsed = parseRecipeFromText(content);
                    if (smartParsed) {
                        conversationHistory.push({role: 'user', content: userInput});
                        conversationHistory.push({role: 'ai', content: smartParsed.message});
                        return smartParsed;
                    }
                    
                    // Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•Ôºå‰Ωú‰∏∫ÊôÆÈÄöÂõûÂ§çÂ§ÑÁêÜ
                    return {
                        type: 'message',
                        message: content.length > 200 ? content.substring(0, 200) + '...' : content
                    };
                }
            }

            // Êô∫ËÉΩËß£ÊûêËèúË∞±ÊñáÊú¨
            function parseRecipeFromText(text) {
                try {
                    // Êü•ÊâæÂèØËÉΩÁöÑËèúÂêç
                    let dishName = 'ÁæéÂë≥‰Ω≥ËÇ¥';
                    const dishMatch = text.match(/["']?dish["']?\s*:\s*["']([^"']+)["']?/i) || 
                                     text.match(/ËèúÂêç[:Ôºö]\s*([^\n,Ôºå]+)/i) ||
                                     text.match(/Êé®Ëçê[:Ôºö]\s*([^\n,Ôºå]+)/i);
                    if (dishMatch) dishName = dishMatch[1].trim();
                    
                    // Êü•ÊâæÁÉπÈ•™Êó∂Èó¥
                    let cookTime = '30ÂàÜÈíü';
                    const timeMatch = text.match(/["']?cooking_time["']?\s*:\s*["']([^"']+)["']?/i) ||
                                     text.match(/Êó∂Èó¥[:Ôºö]\s*([^\n,Ôºå]+)/i) ||
                                     text.match(/(\d+ÂàÜÈíü)/i);
                    if (timeMatch) cookTime = timeMatch[1].trim();
                    
                    // ÊèêÂèñÈ£üÊùêÔºàÁÆÄÂåñÁâàÔºâ
                    const ingredients = [];
                    const ingredientMatches = text.match(/ingredients[\s\S]*?(\[[\s\S]*?\])/i);
                    if (ingredientMatches) {
                        try {
                            const ingredientArray = JSON.parse(ingredientMatches[1]);
                            ingredientArray.forEach(item => {
                                if (typeof item === 'object' && item.name) {
                                    ingredients.push({
                                        name: item.name,
                                        amount: item.amount || 'ÈÄÇÈáè'
                                    });
                                }
                            });
                        } catch (e) {
                            // Ëß£ÊûêÂ§±Ë¥•ÔºåÊ∑ªÂä†ÈªòËÆ§È£üÊùê
                            ingredients.push({name: '‰∏ªË¶ÅÈ£üÊùê', amount: 'ÈÄÇÈáè'});
                        }
                    }
                    
                    // ÊèêÂèñÊ≠•È™§ÔºàÁÆÄÂåñÁâàÔºâ
                    const instructions = [];
                    const stepsMatch = text.match(/steps[\s\S]*?(\[[\s\S]*?\])/i);
                    if (stepsMatch) {
                        try {
                            const stepsArray = JSON.parse(stepsMatch[1]);
                            stepsArray.forEach(item => {
                                if (typeof item === 'object' && item.description) {
                                    instructions.push(item.description);
                                }
                            });
                        } catch (e) {
                            instructions.push('ÊåâÁÖß‰º†ÁªüÊñπÊ≥ïÂà∂‰Ωú');
                        }
                    }
                    
                    // Â¶ÇÊûúÊàêÂäüÊèêÂèñÂà∞‰ø°ÊÅØÔºåËøîÂõûÁªìÊûÑÂåñÊï∞ÊçÆ
                    if (dishName !== 'ÁæéÂë≥‰Ω≥ËÇ¥' || ingredients.length > 0) {
                        return {
                            type: 'recipe',
                            message: `I recommend: ${dishName}`,
                            recipe: {
                                name: dishName,
                                description: `A delicious ${dishName}`,
                                time: cookTime,
                                difficulty: 'Medium',
                                cuisine: 'Home Cooking',
                                ingredients: ingredients.length > 0 ? ingredients : [
                                    {name: 'Main Ingredients', amount: 'As needed'}
                                ],
                                instructions: instructions.length > 0 ? instructions : [
                                    'Prepare the required ingredients',
                                    'Cook using traditional methods',
                                    'Season and plate as desired'
                                ],
                                tips: 'Pay attention to heat control and keep ingredients fresh'
                            }
                        };
                    }
                } catch (e) {
                    console.log('Êô∫ËÉΩËß£ÊûêÂ§±Ë¥•:', e);
                }
                return null;
            }

            // Ê∑ªÂä†ËÅäÂ§©Ê∂àÊÅØ
            function addChatMessage(message, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-bubble ${sender}-bubble fade-in`;
                messageDiv.textContent = message;
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // ÊòæÁ§∫ÊÄùËÄÉÊåáÁ§∫Âô®
            function showTypingIndicator() {
                const typing = document.createElement('div');
                typing.className = 'typing-indicator';
                typing.id = 'typingIndicator';
                typing.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
                chatContainer.appendChild(typing);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            // ÁßªÈô§ÊÄùËÄÉÊåáÁ§∫Âô®
            function removeTypingIndicator() {
                const typing = document.getElementById('typingIndicator');
                if (typing) typing.remove();
            }

            // ÊòæÁ§∫ËèúË∞±ËØ¶ÊÉÖ
            function showRecipeDetail(recipe) {
                document.getElementById('recipeName').textContent = recipe.name;
                document.getElementById('recipeDescription').textContent = recipe.description;
                document.getElementById('recipeTime').textContent = recipe.time;
                document.getElementById('recipeDifficulty').textContent = recipe.difficulty;
                document.getElementById('recipeCuisine').textContent = recipe.cuisine || 'Home Cooking';

                // È£üÊùêÂàóË°®
                const ingredientsList = document.getElementById('ingredientsList');
                ingredientsList.innerHTML = '';
                recipe.ingredients.forEach(ingredient => {
                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center p-2 bg-gray-50 rounded';
                    li.innerHTML = `
                        <span>${ingredient.name}</span>
                        <span class="text-gray-500">${ingredient.amount}</span>
                    `;
                    ingredientsList.appendChild(li);
                });

                // ÁÉπÈ•™Ê≠•È™§
                const instructionsList = document.getElementById('instructionsList');
                instructionsList.innerHTML = '';
                recipe.instructions.forEach((step, index) => {
                    const li = document.createElement('li');
                    li.className = 'flex items-start gap-3 p-3 bg-gray-50 rounded';
                    li.innerHTML = `
                        <span class="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold flex-shrink-0">${index + 1}</span>
                        <span>${step}</span>
                    `;
                    instructionsList.appendChild(li);
                });

                // Â∞èË¥¥Â£´
                document.getElementById('cookingTips').textContent = recipe.tips;

                // ÊòæÁ§∫ËèúË∞±Âå∫ÂüüÂíåÊåâÈíÆ
                recipeDetailSection.classList.remove('hidden');
                actionButtons.classList.remove('hidden');
            }

            // ÈáçÊñ∞ÊêúÁ¥¢
            document.getElementById('newSearchBtn').addEventListener('click', () => {
                // ÈáçÁΩÆÊâÄÊúâÁä∂ÊÄÅ
                conversationHistory = [];
                chatContainer.innerHTML = '';
                chatWelcome.style.display = 'block';
                followUpSection.classList.add('hidden');
                recipeDetailSection.classList.add('hidden');
                actionButtons.classList.add('hidden');
                foodSearchInput.focus();
            });

            // Êç¢‰∏™ËèúË∞±
            document.getElementById('anotherRecipeBtn').addEventListener('click', () => {
                followUpInput.value = 'Can you recommend another similar dish?';
                handleFollowUp();
            });

            // Êî∂ËóèÂäüËÉΩÔºàÁÆÄÂçïÁöÑÊú¨Âú∞Â≠òÂÇ®Ôºâ
            document.getElementById('favoriteBtn').addEventListener('click', function() {
                const recipeName = document.getElementById('recipeName').textContent;
                let favorites = JSON.parse(localStorage.getItem('favoriteRecipes') || '[]');
                
                if (!favorites.includes(recipeName)) {
                    favorites.push(recipeName);
                    localStorage.setItem('favoriteRecipes', JSON.stringify(favorites));
                    this.textContent = 'üíñ Favorited';
                    this.classList.add('text-red-500');
                    
                    // ÊòæÁ§∫ÊèêÁ§∫
                    showToast('Added to favorites!');
                }
            });

            // ÊòæÁ§∫ÊèêÁ§∫Ê∂àÊÅØ
            function showToast(message) {
                const toast = document.createElement('div');
                toast.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50';
                toast.textContent = message;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            }
        });
    </script>
</body>
</html>
 
 
